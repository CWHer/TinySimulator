import dataclasses
from enum import Enum
from typing import List

from operator_class import Operator


class DecisionType(Enum):
    LOAD = 1        # load data from slow memory
    STORE = 2       # store data to slow memory
    ALLOCATE = 3    # allocate fast memory
    PURGE = 4       # purge fast memory (NOTE: generated by the simulator)
    REFER = 5       # make a fast memory pointer
    FORWARD = 6     # run operator forward
    BACKWARD = 7    # run operator backward
    OPTIMIZE = 8    # optimize the parameters
    PRUNE = 9       # prune along output channels (in backward phase)
    COMMIT = 10     # commit the computation (NOTE: generated by the simulator)


ZERO_COST_DECISIONS = [
    DecisionType.COMMIT, DecisionType.PRUNE,
    DecisionType.ALLOCATE, DecisionType.REFER,  DecisionType.PURGE
]


COMPUTE_DECISIONS = {
    DecisionType.FORWARD: "forward",
    DecisionType.BACKWARD: "backward",
    DecisionType.OPTIMIZE: "optimize"
}


class MemoryBlockType(Enum):
    PARAM = "param"
    INPUT = "input"
    OUTPUT = "output"
    GRAD = "grad"
    PASS_GRAD = "pass_grad"


@dataclasses.dataclass
class Decision:
    wall_time: float  # when this decision happens
    decision_type: DecisionType

    operator: Operator  # apply to which operator
    # which memory block to load/store/allocate
    memory_block: MemoryBlockType
    # (NOTE: num input channels for forward, num output channels for backward)
    channel_ids: List[int]  # apply to which channels

    # NOTE: this is only for commit decision
    #   is this commit the last commit for forward/backward ?
    is_last: bool = False

    def __hash__(self) -> int:
        return id(self)


def decisionRank(x: Decision):
    # NOTE: when some decisions have the same wall_time,
    #   we need to compute them in certain order
    index = len(ZERO_COST_DECISIONS) \
        if not x.decision_type in ZERO_COST_DECISIONS \
        else ZERO_COST_DECISIONS.index(x.decision_type)
    return x.wall_time * (len(ZERO_COST_DECISIONS) + 1) + index
